package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"bytes"
	"context"
	"crypto/rand"
	"encoding/json"
	"fmt"
	"log"
	"math/big"
	"server/elastic"
	"server/graph/model"
	"strings"

	"github.com/elastic/go-elasticsearch/v8/esapi"
)

// CreateSamEntity is the resolver for the createSamEntity field.
func (r *mutationResolver) CreateSamEntity(ctx context.Context, input model.NewEntity) (*model.SamEntity, error) {
	randNumber, _ := rand.Int(rand.Reader, big.NewInt(100))
	entity := &model.SamEntity{
		ID:       fmt.Sprintf("D%d", randNumber),
		Name:     input.Name,
		CageCode: input.CageCode,
	}

	entityJSON, err := json.Marshal(entity)
	if err != nil {
		return nil, err
	}

	es := elastic.GetES()

	req := esapi.IndexRequest{
		Index:      "sam_entities",
		DocumentID: entity.ID,
		Body:       strings.NewReader(string(entityJSON)),
		Refresh:    "true",
	}

	res, err := req.Do(ctx, es)
	if err != nil {
		log.Printf("Error getting response: %s", err)
		return nil, err
	}
	defer res.Body.Close()

	log.Printf("response: %s", res)
	log.Printf("Created entity with ID: %s", entity.ID)

	return entity, nil
}

// SamEntities is the resolver for the SamEntities field.
func (r *queryResolver) SamEntities(ctx context.Context, first *int, offset *int, before *string, after *string, search *string) (*model.SamEntityConnection, error) {
	// Check for nil parameters passed to query
	var limit int
	if first != nil {
		limit = *first
	} else {
		limit = 10 // Default limit
	}

	var searchAfter []interface{}
	var searchBefore []interface{}
	if after != nil {
		searchAfter = []interface{}{*after}
	}
	if before != nil {
		searchBefore = []interface{}{*before}
	}

	es := elastic.GetES()
	var err error

	// Count Query to get the total number of documents
	countReq := esapi.CountRequest{
		Index: []string{"sam_entities"},
	}

	countRes, err := countReq.Do(ctx, es)
	if err != nil {
		return nil, err
	}
	defer countRes.Body.Close()

	var countResponse model.Count
	if err := json.NewDecoder(countRes.Body).Decode(&countResponse); err != nil {
		log.Printf("Error parsing the count response body: %s", err)
		return nil, err
	}

	var searchQuery map[string]interface{}
	if search != nil {
		searchQuery =
			map[string]interface{}{
				"size": limit + 1,
				"query": map[string]interface{}{
					"bool": map[string]interface{}{
						"should": []map[string]interface{}{
							{
								"wildcard": map[string]interface{}{
									"name": "*" + *search + "*",
								},
							},
							{
								"wildcard": map[string]interface{}{
									"cage_code": "*" + *search + "*",
								},
							},
						},
					},
				},
				"sort": []map[string]interface{}{
					{"name.keyword": "asc"},
				},
			}

	} else {
		searchQuery = map[string]interface{}{
			"size": limit + 1,
			"query": map[string]interface{}{
				"match_all": map[string]interface{}{},
			},
			"sort": []map[string]interface{}{
				{"name.keyword": "asc"},
			},
		}
	}

	// Set some params
	if searchBefore != nil {
		searchQuery["sort"] = []map[string]interface{}{
			{"name.keyword": "desc"},
		}
		searchQuery["search_after"] = searchBefore
	}
	if searchAfter != nil {
		searchQuery["search_after"] = searchAfter
	}
	if offset != nil {
		searchQuery["from"] = *offset
	}

	// Hers our final query, time to search and resolve
	log.Printf("%+v", searchQuery)

	var searchBuffer bytes.Buffer
	if err := json.NewEncoder(&searchBuffer).Encode(searchQuery); err != nil {
		return nil, err
	}
	req := esapi.SearchRequest{
		Index: []string{"sam_entities"},
		Body:  &searchBuffer,
	}
	res, err := req.Do(ctx, es)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	var esResponse model.ElasticsearchResponse
	if err := json.NewDecoder(res.Body).Decode(&esResponse); err != nil {
		log.Printf("Error parsing the search response body: %s", err)
		return nil, err
	}

	// Yayyy results
	//log.Printf("%+v", esResponse)

	// Now we need to resolve to our graphql schema
	var paged_entities model.SamEntityConnection
	if esResponse.Hits.Total.Value > 0 {
		entities := []*model.SamEntity{}
		edges := []*model.SamEntityEdge{}

		// If we have a search before in our query, then we need to re-order the
		// data back to asc order
		response_length := len(esResponse.Hits.Hits)

		for i := 0; i < response_length; i++ {
			hits := esResponse.Hits
			if searchBefore != nil {
				entity := &hits.Hits[(response_length-1)-i].Source
				edge := &model.SamEntityEdge{
					Node:   entity,
					Cursor: entity.Name,
				}
				entities = append(entities, entity)
				edges = append(edges, edge)
			} else {
				entity := &hits.Hits[i].Source
				edge := &model.SamEntityEdge{
					Node:   entity,
					Cursor: entity.Name,
				}
				entities = append(entities, entity)
				edges = append(edges, edge)
			}
		}

		nextPage := false
		// If theres no offset then we don't have a previous page
		previousPage := offset != nil && *offset > 0
		if len(entities) > limit {
			entities = entities[:limit]
			edges = edges[:limit]
			nextPage = true
		}

		var startC, endC *string
		if len(edges) > 0 {
			endC = &edges[len(edges)-1].Cursor
			startC = &edges[0].Cursor
		}

		paged_entities = model.SamEntityConnection{
			Nodes:       entities,
			Edges:       edges,
			TotalCount:  countResponse.Count,
			TotalSearch: esResponse.Hits.Total.Value,
			PageInfo: &model.PageInfo{
				StartCursor:     startC,
				EndCursor:       endC,
				HasNextPage:     nextPage,
				HasPreviousPage: previousPage,
			},
		}
	} else {
		paged_entities = model.SamEntityConnection{
			Nodes:      nil,
			Edges:      nil,
			TotalCount: 0,
			PageInfo:   nil,
		}
	}

	return &paged_entities, err
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
